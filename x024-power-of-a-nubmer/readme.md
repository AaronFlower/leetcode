## Computing the nth power of a number.

如何最快的计算一个 x^n 那？

### Shortest Add Chain 最短加法链

这个问题在 TAOCP 上有一个专题，非常有意思。(Section 4.6.3 in vol. 2 of Knuth’s “The Art of Computer Programming").

假设我们要计算： x^10, 可以通过下面的步骤来计算：

1. x                 // 1
2. x^2  = x * x      // 2
3. x^4  = x^2 * x^2  // 4
4. x^8  = x^4 * x^4  // 8
5. x^10 = x^8 * x^2  // 2

我们可以不用关心 x 到底是什么。x 可以是很大的数，很小的数，浮点数，也可以是矩阵。

（By the way, 邻接矩阵相乘来求具体的路径步数也很赞）

上面的计算步骤我们可以确定一个序列：`1, 2, 4, 8, 10`。这个序列我们称之为加法链 （addition chain)。

**加法链**，是一个数字序列，该序列以 1 开始，后面每一个元素都是前面数字组合而成（数字可以相同）。这个序列不包含 1 的长度，称之为加法链的长度，即我们需要花的步数。

下面两个加法链我们都可以得到 10 ：

```
a) 1, 2, 4, 5, 10
b) 1, 2, 4, 8, 10 (greedy, 贪心)
```

可以证明，10 的加法链长度最小为 4，最短加法链长度 `l(10) = 4`;

所以计算 x^n 的最优算法就是寻找最短的加法链 `l(n)`。

`23, 191, 3^1729` 的加法链怎么寻找？

寻找加法链的一种有效的方法是 doubling (倍加），即每次对上一个元素乘 2 即可。

有一种简单的方法来计算 n 的 doubles, 即通过二进制的方法表示。其步骤为：

1. 将数字写成二进制表示的形式
2. 去掉其最高位的 `1`
3. 将每个 `1` 替换成 `D1`
4. 将每个 `0` 替换成 `D`
5. 替换后的字符串中 `D` 表示 double, `1` 表示 add 1

以 10 为例：

1. 10 的二进制表示为 (1010)
2. 去掉最高位的1 为： 010
3. 替换后的字符串为：DD1D (double, double, add, double)
4. 所以加法链序列可以写为: 1, 2, 4, 5, 10.

上面的二进制方法有人认为是最有效的方法，但其实并不是，如：15 的二进制表示为 (1111), 去掉最高位替换字符串为 (D1D1D1), 得到的序列为：`1,2,3,6,7,14,15`, 但其实最有效的序列是: `1,2,3,6,12,15`。


**问题**，给定一个数求其最短的加法链？

最短加法链的算法还是很 subtle 的。不过在求 x^n 的时候用上面的二进制方法也可以，但不一定是最优。但效率也是可以了。


### 另一种解法

另外给出一个计算 x^n 次幂的算法，其时间复杂度为 O(n) 或 (O(b), b 为 n 中为 1 的 bit 位个数）。

```python
pow(x, n):
    res = 1
    while n > 0:
        if n & 1:
            res = res * x
        x = x * x
        n >>= 1
    return res
```

因为 x^n 中的 n 可以用二进制的底表示，即：

n = 2^k1 + 2^k2 + ... + 2^km

所以 x^n 可以表示为：

x^n = x^(2^k1) * x^(2^k2) * x^(2^km)

e.g.

n = 25 = (11001)₂

x^25 = x^16 * x^8 * x
