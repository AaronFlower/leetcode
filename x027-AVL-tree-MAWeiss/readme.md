## AVL tree

AVL(Adelson-Velskii and Landis) 带有平衡条件的二叉搜索树。

- 一棵 AVL 树是其每个节点的左子树和右子树的高度(height) 最多差 1 的二叉搜索树。
- 一棵 AVL 树的高度最多为: 1.44log(N + 2) - 1.328 , 需要看论文推导。但是实际上只比 log(N) 稍微高一点而已。
- 队了插入外，所有操作都为 O(lgN), (删除话，我们使用懒惰删除(lazy deletion), 打个标记即可）.
- 插入可能会破坏 AVL 树的平衡条件，我们需要旋转（rotation) 进行调用来修正。

在插入新的节点后，只有插入点到根节点的路径上的节点的平衡条件可能被改变，寻找到平衡性被打破的点 a 。即 a 的两棵子树的高度差 2 。容易看出，不平衡性在下面四种情况下才会出现：

a) 对 a 的左儿子的左子树进行一次插入。
b) 对 a 的左儿子的右子树进行一次插入。
c) 对 a 的右儿子的左子树进行一次插入。
d) 对 a 的右儿子的右子树进行一次插入。

上面 4 种情况, a 和 d 是对称的，而 b 和 c 也是对称的，所以理论上只有 2 种情况。即:

1. 插入发生在『外边』，即 左-左 （或 右-右）的情况，需要一次旋转。
2. 插入发生在『内部』，即 左-右 （或 右-左）的情况，需要二次旋转。

插入操作的编程实现：

将 x 插入到 T 中，我们递归的将 x 插入到 T 的相应子树（Tsub) 中。如果 Tsub 的高度不变，则插入完成。如果 T 中出现了不平衡，根据 x, T, Tsub 的关键字进行单旋转或双旋转（更新高度并做连接重新赋值）。

在实现时还是用递归实现比较容易些。在实现时我们需要获取树的高度信息，那我们可以把树的高度信息存储下来，即只存储子树的差老即可 （-1, 0, 1);
